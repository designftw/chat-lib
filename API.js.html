<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      API.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-light.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="7639887" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="Account.html">Account</a></li><li class="accordion-list" id=""><a href="Alias.html">Alias</a></li><li class="accordion collapsed child" id=1956989><div class="accordion-heading child"><a href="AliasesEndpoint.html">AliasesEndpoint</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="AliasesEndpoint.html#createAlias">createAlias</a></li><li data-type='method'><a href="AliasesEndpoint.html#deleteAlias">deleteAlias</a></li><li data-type='method'><a href="AliasesEndpoint.html#getAlias">getAlias</a></li><li data-type='method'><a href="AliasesEndpoint.html#getAliasesForAccount">getAliasesForAccount</a></li><li data-type='method'><a href="AliasesEndpoint.html#updateAlias">updateAlias</a></li></ul></li><li class="accordion-list" id=""><a href="API.html">API</a></li><li class="accordion collapsed child" id=1150314><div class="accordion-heading child"><a href="AuthEndpoint.html">AuthEndpoint</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="AuthEndpoint.html#isLoggedIn">isLoggedIn</a></li><li data-type='method'><a href="AuthEndpoint.html#login">login</a></li><li data-type='method'><a href="AuthEndpoint.html#logout">logout</a></li><li data-type='method'><a href="AuthEndpoint.html#signup">signup</a></li></ul></li><li class="accordion-list" id=""><a href="BaseModel.html">BaseModel</a></li><li class="accordion collapsed child" id=6298312><div class="accordion-heading child"><a href="Client.html">Client</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Client.html#addFriend">addFriend</a></li><li data-type='method'><a href="Client.html#createAlias">createAlias</a></li><li data-type='method'><a href="Client.html#createPrivatePayload">createPrivatePayload</a></li><li data-type='method'><a href="Client.html#deleteAlias">deleteAlias</a></li><li data-type='method'><a href="Client.html#deleteMessage">deleteMessage</a></li><li data-type='method'><a href="Client.html#deletePrivatePayload">deletePrivatePayload</a></li><li data-type='method'><a href="Client.html#getAlias">getAlias</a></li><li data-type='method'><a href="Client.html#getAliasesForAccount">getAliasesForAccount</a></li><li data-type='method'><a href="Client.html#getFriendsForAlias">getFriendsForAlias</a></li><li data-type='method'><a href="Client.html#getMessageById">getMessageById</a></li><li data-type='method'><a href="Client.html#getMessagesForAlias">getMessagesForAlias</a></li><li data-type='method'><a href="Client.html#getPrivatePayload">getPrivatePayload</a></li><li data-type='method'><a href="Client.html#groupMessagesByUniqueRecipients">groupMessagesByUniqueRecipients</a></li><li data-type='method'><a href="Client.html#isLoggedIn">isLoggedIn</a></li><li data-type='method'><a href="Client.html#login">login</a></li><li data-type='method'><a href="Client.html#logout">logout</a></li><li data-type='method'><a href="Client.html#removeFriend">removeFriend</a></li><li data-type='method'><a href="Client.html#sendMessage">sendMessage</a></li><li data-type='method'><a href="Client.html#signup">signup</a></li><li data-type='method'><a href="Client.html#updateAlias">updateAlias</a></li><li data-type='method'><a href="Client.html#updateMessage">updateMessage</a></li><li data-type='method'><a href="Client.html#updatePrivatePayload">updatePrivatePayload</a></li></ul></li><li class="accordion-list" id=""><a href="ClientStore.html">ClientStore</a></li><li class="accordion collapsed child" id=5871501><div class="accordion-heading child"><a href="FriendsEndpoint.html">FriendsEndpoint</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="FriendsEndpoint.html#addFriend">addFriend</a></li><li data-type='method'><a href="FriendsEndpoint.html#getFriendsForAlias">getFriendsForAlias</a></li><li data-type='method'><a href="FriendsEndpoint.html#removeFriend">removeFriend</a></li></ul></li><li class="accordion-list" id=""><a href="Message.html">Message</a></li><li class="accordion collapsed child" id=8421634><div class="accordion-heading child"><a href="MessagesEndpoint.html">MessagesEndpoint</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="MessagesEndpoint.html#deleteMessage">deleteMessage</a></li><li data-type='method'><a href="MessagesEndpoint.html#getMessage">getMessage</a></li><li data-type='method'><a href="MessagesEndpoint.html#getMessagesForAlias">getMessagesForAlias</a></li><li data-type='method'><a href="MessagesEndpoint.html#sendMessage">sendMessage</a></li><li data-type='method'><a href="MessagesEndpoint.html#updateMessage">updateMessage</a></li></ul></li><li class="accordion-list" id=""><a href="PrivatePayload.html">PrivatePayload</a></li><li class="accordion collapsed child" id=9493634><div class="accordion-heading child"><a href="PrivatePayloadsEndpoint.html">PrivatePayloadsEndpoint</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="PrivatePayloadsEndpoint.html#createPayload">createPayload</a></li><li data-type='method'><a href="PrivatePayloadsEndpoint.html#deletePayload">deletePayload</a></li><li data-type='method'><a href="PrivatePayloadsEndpoint.html#getPayload">getPayload</a></li><li data-type='method'><a href="PrivatePayloadsEndpoint.html#updatePayload">updatePayload</a></li></ul></li><li class="accordion collapsed child" id=3933053><div class="accordion-heading child"><a href="WebSocketEndpoint.html">WebSocketEndpoint</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="WebSocketEndpoint.html#openWebSocketFor">openWebSocketFor</a></li></ul></li></ul> </div><div class="accordion collapsed" id="9087618" > <h3 class="accordion-heading">Events<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#event:onDeleteMessage">onDeleteMessage</a></li><li class="accordion-list" id=""><a href="global.html#event:onNewMessage">onNewMessage</a></li><li class="accordion-list" id=""><a href="global.html#event:onUpdateMessage">onUpdateMessage</a></li></ul> </div><div class="accordion collapsed" id="4219477" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#createAccountFromAccountDTO">createAccountFromAccountDTO</a></li><li class="accordion-list" id=""><a href="global.html#createAliasFromAliasDTO">createAliasFromAliasDTO</a></li><li class="accordion-list" id=""><a href="global.html#createDefaultRequestInit">createDefaultRequestInit</a></li><li class="accordion-list" id=""><a href="global.html#CreateDefaultRequestInitOptions">CreateDefaultRequestInitOptions</a></li><li class="accordion-list" id=""><a href="global.html#createJSONEncodedBody">createJSONEncodedBody</a></li><li class="accordion-list" id=""><a href="global.html#createMessageFromMessageDTO">createMessageFromMessageDTO</a></li><li class="accordion-list" id=""><a href="global.html#createPrivatePayloadFromPayloadDTO">createPrivatePayloadFromPayloadDTO</a></li><li class="accordion-list" id=""><a href="global.html#getErrorFromResponse">getErrorFromResponse</a></li><li class="accordion-list" id=""><a href="global.html#messageEventDetails">messageEventDetails</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        API.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import ClientStore from "./ClientStore.js";
import Account from "./Account.js";
import Alias from "./Alias.js";
import Message from "./Message.js";
import PrivatePayload from "./PrivatePayload.js";

import {
  createAccountFromAccountDTO,
  createAliasFromAliasDTO,
  createMessageFromMessageDTO,
  createPrivatePayloadFromPayloadDTO,
  getErrorFromResponse,
  createDefaultRequestInit,
} from "./util.js";
import Client from "./Client.js";

/**
 * The interface for interacting with the ChatServer API.
 */
class API {
  /**
   * API constructor.
   *
   * @param {ClientStore} store see [Client's store property]{@link Client#store}
   * @param {Client} client see [Client]{@link Client}
   */
  constructor(store, client) {
    /**
     * See [Client's store property]{@link Client#store}
     * @type {ClientStore}
     */
    this.store = store;

    /**
     * See [Client]{@link Client}
     * @type {Client}
     */
    this.client = client;

    /**
     * Helper class for authorization routes.
     * @type {AuthEndpoint}
     */
    this.auth = new AuthEndpoint(this.store);

    /**
     * Helper class for alias routes.
     * @type {AliasesEndpoint}
     */
    this.aliases = new AliasesEndpoint(store);

    /**
     * Helper class for message routes.
     * @type {MessagesEndpoint}
     */
    this.messages = new MessagesEndpoint(store);

    /**
     * Helper class for private payload routes.
     * @type {PrivatePayloadsEndpoint}
     */
    this.privatePayloads = new PrivatePayloadsEndpoint(store);

    /**
     * Helper class for friends routes.
     * @type {FriendsEndpoint}
     */
    this.friends = new FriendsEndpoint(store);

    this.webSocket = new WebSocketEndpoint(store, client);
  }
}

/**
 * Helper class for communicating with web sockets on the chat server.
 */
class WebSocketEndpoint {
  /**
   * Private object mapping alias ids to open web sockets.
   * @type {Object.&lt;number, WebSocket>}
   */
  #aliasNameToWebSocket;

  /**
   * WebSocketEndpoint constructor.
   *
   * @param {ClientStore} store see [Client's store property]{@link Client#store}
   * @param {Client} client see [Client]{@link Client}
   */
  constructor(store, client) {
    /**
     * See [Client's store property]{@link Client#store}
     * @type {ClientStore}
     */
    this.store = store;

    /**
     * See [Client]{@link Client}
     * @type {Client}
     */
    this.client = client;

    this.#aliasNameToWebSocket = {};
  }

  /**
   * Returns an open web socket which can be used to send and receive messages.
   * @param {string} aliasName the alias to get the web socket for.
   * @returns {Promise&lt;WebSocket>}
   */
  #getWebSocketForAlias(aliasName) {
    // if the socket exists return it
    if (this.#aliasNameToWebSocket.hasOwnProperty(aliasName)) {
      return Promise.resolve(this.#aliasNameToWebSocket[aliasName]);
    }
    return new Promise((resolve, reject) => {
      let socket = new WebSocket(
        `${this.store.host.replace(
          "https://",
          "wss://"
        )}/realtime?alias=${aliasName}`
      );
      // handle the open event
      socket.addEventListener(
        "open",
        () => {
          this.#aliasNameToWebSocket[aliasName] = socket;
          resolve(socket);
        },
        { once: true }
      );
      // handle the error event
      socket.addEventListener(
        "error",
        (err) => {
          reject(err);
        },
        { once: true }
      );
      socket.addEventListener(
        "close",
        () => {
          delete this.#aliasNameToWebSocket[aliasName];
        },
        { once: true }
      );
      socket.addEventListener("message", (e) => {
        const data = JSON.parse(e.data);
        if (data.type === "new_message") {
          this.client.dispatchEvent(
            new CustomEvent("onNewMessage", {
              detail: {
                messageId: data.messageId,
                aliasName,
              },
            })
          );
        }
        if (data.type === "message_update") {
          this.client.dispatchEvent(
            new CustomEvent("onUpdateMessage", {
              detail: {
                messageId: data.messageId,
                aliasName,
              },
            })
          );
        }
        if (data.type === "message_delete") {
          this.client.dispatchEvent(
            new CustomEvent("onDeleteMessage", {
              detail: {
                messageId: data.messageId,
                aliasName,
              },
            })
          );
        }
        if (data.type === "unauthorized") {
          new CustomEvent("onUnauthorizedAccess", {
            detail: { message: data.message, aliasName },
          });
        }
      });
    });
  }

  /**
   *
   * @param {string} aliasName an alias to open a web socket for
   */
  openWebSocketFor(aliasName) {
    return this.#getWebSocketForAlias(aliasName).then((res) => ({
      message: "successfully opened web socket",
    }));
  }
}

/**
 * Helper class for authentication routes.
 */
class AuthEndpoint {
  /**
   * AuthEndpoint constructor.
   *
   * @param {ClientStore} store see [Client's store property]{@link Client#store}
   */
  constructor(store) {
    /**
     * See [Client's store property]{@link Client#store}
     * @type {ClientStore}
     */
    this.store = store;
  }

  /**
   * Sign up for a new account with a single initial alias.
   * @param {string} alias The name of the initial alias if signup is successful.
   * @param {string} email The email address associated with the account.
   * @param {string} password The password associated with the account.
   * @returns {Promise&lt;any>} A success message upon successful login
   */
  signup(alias, email, password) {
    let route = "signup";
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "POST",
        body: { alias, email, password },
      })
    )
      .then(getErrorFromResponse)
      .then((res) => res.json());
  }

  /**
   * Login to an existing account.
   * @param {string} email The email address associated with the account.
   * @param {string} password The password associated with the account.
   * @returns {Promise&lt;Account>} Upon success returns the account which was logged in.
   */
  login(email, password) {
    let route = "login";
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "POST",
        body: { email, password },
      })
    )
      .then(getErrorFromResponse)
      .then((res) => res.json())
      .then((res) => {
        return createAccountFromAccountDTO(res.account);
      });
  }

  /**
   * Logout of the currently logged in account
   * @returns {Promise&lt;void>} Upon success returns nothing.
   */
  logout() {
    let route = "logout";
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "POST" })
    )
      .then(getErrorFromResponse)
      .then((res) => {
        return;
      });
  }

  /**
   * Check if the client is currently logged in
   * @returns {Promise&lt;{isLoggedIn: boolean, account: Account | undefined}>} an
   * object with two keys isLoggedIn and account. If isLoggedIn is true then
   * account contains has the currently logged in account. If isLoggedIn is
   * false then account is undefined.
   */
  isLoggedIn() {
    let route = "isloggedin";
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "GET" })
    )
      .then(getErrorFromResponse)
      .then((res) => res.json())
      .then((json) => {
        return {
          isLoggedIn: json.response,
          account: json.data
            ? createAccountFromAccountDTO(json.data)
            : undefined,
        };
      });
  }
}

/**
 * The aliases endpoint of the chat server.
 */
class AliasesEndpoint {
  /**
   * AliasesEndpoint constructor.
   *
   * @param {ClientStore} store see [Client's store property]{@link Client#store}
   */
  constructor(store) {
    /**
     * See [Client's store property]{@link Client#store}
     * @type {ClientStore}
     */
    this.store = store;
  }

  /**
   * Get all the aliases associated with the currently logged in account.
   * @returns {Promise&lt;Alias[]>} the aliases associated with the currently logged in account
   */
  getAliasesForAccount() {
    let route = "aliases";
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "GET" })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((aliasesArray) => {
        return aliasesArray.map((aliasDTO) => {
          return createAliasFromAliasDTO(aliasDTO);
        });
      });
  }

  /**
   * Create a new alias associated with the currently logged in account.
   *
   * Raises an error if the alias already exists.
   * @param {string} name the name of the alias to create
   * @param {string } payload payload to attach to the new alias
   * @returns {Promise&lt;Alias>}
   */
  createAlias(name, payload) {
    let route = "aliases";
    return fetch(
      `${this.store.host}/${route}`,

      createDefaultRequestInit({
        method: "POST",
        body: {
          name,
          payload,
        },
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((newAliasDTO) => {
        const aliasDTO = newAliasDTO.data;
        return createAliasFromAliasDTO(aliasDTO);
      });
  }

  /**
   * Get an existing alias by its name.
   *
   * Raises an error if the alias does not exist.
   * @param {string} aliasName the name of the alias to get.
   * @returns {Promise&lt;Alias>}
   */
  getAlias(aliasName) {
    let route = `aliases/${aliasName}`;
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "GET" })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((aliasDTO) => {
        return createAliasFromAliasDTO(aliasDTO);
      });
  }

  /**
   * Update an existing alias by its name.
   *
   * Raises an error if the alias does not exist or belong to the currently logged in account.
   * @param {Alias} alias the alias to update.
   * @param {string} [newName] optional updated name of the alias. if not included alias retains the same name.
   * @param {string} [newPayload] optional updated payload of the alias. if not included alias retains the same payload.
   * @returns {Promise&lt;Alias>}
   */
  updateAlias(alias, newName, newPayload) {
    let route = `aliases/${alias.name}`;
    if (newName === undefined) {
      newName = alias.name;
    }
    if (newPayload === undefined) {
      newPayload = alias.payload;
    }
    return fetch(
      `${this.store.host}/${route}`,

      createDefaultRequestInit({
        method: "PUT",
        body: { name: newName, payload: newPayload },
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((updatedAliasDTO) => {
        const aliasDTO = updatedAliasDTO.data;
        return createAliasFromAliasDTO(aliasDTO);
      });
  }

  /**
   * Delete an existing alias by its name
   *
   * Raises an error if the alias does not exist or belong to the currently logged in account.
   * @param {string} aliasName the alias to delete.
   * @returns {Promise&lt;any>} a validation message.
   */
  deleteAlias(aliasName) {
    let route = `aliases/${aliasName}`;
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "DELETE" })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json());
  }
}

/**
 * The messages endpoint of the chat server.
 */
class MessagesEndpoint {
  /**
   * AliasesEndpoint constructor.
   *
   * @param {ClientStore} store see [Client's store property]{@link Client#store}
   */
  constructor(store) {
    /**
     * See [Client's store property]{@link Client#store}
     * @type {ClientStore}
     */
    this.store = store;
  }

  /**
   * Get all the messages sent or received by the alias and the passed in interlocutors.
   *
   * If no interlocutors are passed in, returns all the messages sent or received by the alias.
   *
   * If for example the passed in interlocutors contains the id for the alias Sally, and the passed
   * in alias is Jack, then this method returns all messages sent by Jack to Sally, or by Sally to Jack.
   * If there are multiple interlocutors this method returns all messages sent by Jack to any of the
   * interlocutors, or by any of the interlocutors to Jack. Note this does not mean that the message
   * has to be sent to all of the interlocutors to be here. Any pair suffices.
   * @param {string} ownAlias an alias associated with the currently logged in account
   * @param {string[] | undefined} interlocutors An optional list of aliases which are either the sender or receiver of the returned messages..
   * @param {Date | undefined} sinceTime An optional date which filters messages to those which were sent after this time.
   * @returns {Promise&lt;Message[]>} The messages which pass the filters.
   */
  getMessagesForAlias(
    ownAlias,
    interlocutors = undefined,
    sinceTime = undefined
  ) {
    let route = `messages`;
    // create the headers for the message get request
    let headers = {
      "user-alias-name": ownAlias,
    };
    if (interlocutors !== undefined) {
      headers = { ...headers, interlocutors: JSON.stringify(interlocutors) };
    }
    if (sinceTime !== undefined) {
      headers = { ...headers, "since-time": sinceTime.getTime() };
    }
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "GET", headers: headers })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((messagesDTO) => {
        return messagesDTO.map((messageDTO) =>
          createMessageFromMessageDTO(messageDTO)
        );
      });
  }

  /**
   * Send a new message from ownAlias to recipients. The payload is a potentially jsonified string.
   * @param {string} ownAlias an alias associated with the currently logged in account.
   * @param {string[]} recipientNames the recipients of the message
   * @param {string} messagePayload the payload of the message
   * @returns {Promise&lt;Message>} The sent message.
   */
  sendMessage(ownAlias, recipientNames, messagePayload) {
    let route = `messages`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    const body = {
      payload: messagePayload,
      recipients: recipientNames,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "POST",
        body,
        headers,
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((responseDTO) => {
        const messageDTO = responseDTO.data;
        return this.getMessage(ownAlias, messageDTO.id);
      });
  }

  /**
   * Get a single message by it's id.
   * @param {string} ownAlias the alias associated with the message id, either the sender or recipient.
   * @param {string} messageId The Message Id. see [Message's id property]{@link Message#id}
   * @returns {Promise&lt;Message>} The message associated with the passed in id.
   */
  getMessage(ownAlias, messageId) {
    let route = `messages/${messageId}`;
    // create the headers for the message get request
    let headers = {
      "user-alias-name": ownAlias,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "GET", headers: headers })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((messageDTO) => createMessageFromMessageDTO(messageDTO));
  }

  /**
   * Update a single message by it's id.
   * @param {string} ownAlias the alias associated with the message id. Must be the sender of the message.
   * @param {string} messageId The Message Id. see [Message's id property]{@link Message#id}
   * @param {string} payload The new payload to be associated with the message. See [Message's payload property]{@link Message#payload}
   * @returns {Promise&lt;Message>} The updated message
   */
  updateMessage(ownAlias, messageId, payload) {
    let route = `messages/${messageId}`;
    // create the headers for the message get request
    let headers = {
      "user-alias-name": ownAlias,
    };
    const body = { payload };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "PUT",
        body,
        headers,
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((resultDTO) => {
        const messageDTO = resultDTO.data;
        return this.getMessage(ownAlias, messageDTO.id);
      });
  }

  /**
   * Delete a single message by it's id.
   * @param {string} ownAlias the alias associated with the message id, either the sender or recipient.
   * @param {string} messageId The Message Id. see [Message's id property]{@link Message#id}
   * @returns {Promise&lt;any>} A validation message.
   */
  deleteMessage(ownAlias, messageId) {
    let route = `messages/${messageId}`;
    // create the headers for the message get request
    let headers = {
      "user-alias-name": ownAlias,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "DELETE",
        headers,
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json());
  }
}

/**
 * The Private Payload endpoint of the chat server
 */
class PrivatePayloadsEndpoint {
  /**
   * PrivatePayloadEndpoint constructor.
   *
   * @param {ClientStore} store see [Client's store property]{@link Client#store}
   */
  constructor(store) {
    /**
     * See [Client's store property]{@link Client#store}
     * @type {ClientStore}
     */
    this.store = store;
  }

  /**
   * Create a new private payload.
   * @param {string} ownAlias the alias associated with the private payload.
   * @param {string} entityId the [id]{@link BaseModel#id} of the entity the payload is attached to.
   * @param {string} payload the payload, private to the passed in alias, to be attached to the passed in model.
   * @returns {Promise&lt;PrivatePayload>} the newly created private payload.
   */
  createPayload(ownAlias, entityId, payload) {
    let route = `payloads`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    const body = { payload, entity_id: entityId };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "POST",
        body,
        headers,
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((resultDTO) => {
        const payloadDTO = resultDTO.data;
        return createPrivatePayloadFromPayloadDTO(payloadDTO);
      });
  }

  /**
   * Get the payload associated with the passed in alias and entity.
   * @param {string} ownAlias the alias associated with the private payload.
   * @param {string} entityId the [id]{@link BaseModel#id} of the entity the returned payload is attached to.
   * @returns {Promise&lt;PrivatePayload>} the requested PrivatePayload model.
   */
  getPayload(ownAlias, entityId) {
    let route = `payloads/${entityId}`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "GET", headers: headers })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((payloadDTO) => {
        return createPrivatePayloadFromPayloadDTO(payloadDTO);
      });
  }

  /**
   * Update the payload associated with the passed in alias and entity.
   * @param {string} ownAlias the alias associated with the private payload.
   * @param {string} entityId the [id]{@link BaseModel#id} of the entity the payload to update is attached to.
   * @param {string} newPayload the new payload to attach to the alias and model
   * @returns {Promise&lt;PrivatePayload>} the updated private payload model.
   */
  updatePayload(ownAlias, entityId, newPayload) {
    let route = `payloads/${entityId}`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    const body = { payload: newPayload };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "PUT",
        body,
        headers,
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((resultDTO) => {
        const payloadDTO = resultDTO.data;
        return createPrivatePayloadFromPayloadDTO(payloadDTO);
      });
  }

  /**
   * Delete the payload associated with the passed in alias and entity.
   * @param {string} ownAlias the alias associated with the private payload.
   * @param {string} entityId the [id]{@link BaseModel#id} of the entity the payload to delete is attached to.
   * @returns {Promise&lt;any>} a validation message.
   */
  deletePayload(ownAlias, entityId) {
    let route = `payloads/${entityId}`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "DELETE", headers })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json());
  }
}

/**
 * The Friends endpoint of the chat server
 */
class FriendsEndpoint {
  /**
   * FriendsEndpoint constructor.
   *
   * @param {ClientStore} store see [Client's store property]{@link Client#store}
   */
  constructor(store) {
    /**
     * See [Client's store property]{@link Client#store}
     * @type {ClientStore}
     */
    this.store = store;
  }

  /**
   * Get all the friends of the passed in alias.
   * @param {string} ownAlias the alias whose friends will be retrieved.
   * @returns {Promise&lt;Alias[]>} an array of aliases which are friends with the passed in alias
   */
  getFriendsForAlias(ownAlias) {
    let route = `friends`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({ method: "GET", headers: headers })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json())
      .then((friendsListDTO) =>
        friendsListDTO.map((aliasDTO) => createAliasFromAliasDTO(aliasDTO))
      );
  }

  /**
   * Add a new friend to the friend list of ownAlias.
   * @param {string} ownAlias the alias adding a friend.
   * @param {string} newFriend the new friend of the ownAlias.
   * @returns {Promise&lt;any>} a validation message.
   */
  addFriend(ownAlias, newFriend) {
    let route = `friends`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    const body = {
      alias_name: newFriend,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "POST",
        body,
        headers,
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json());
  }

  /**
   * Remove a friend from the friend list of ownAlias.
   * @param {string} ownAlias the alias removing a friend.
   * @param {string} friendToRemove the friend to remove from ownAlias's friend list.
   * @returns {Promise&lt;any>} a validation message.
   */
  removeFriend(ownAlias, friendToRemove) {
    let route = `friends`;
    let headers = {
      "user-alias-name": ownAlias,
    };
    const body = {
      alias_name: friendToRemove,
    };
    return fetch(
      `${this.store.host}/${route}`,
      createDefaultRequestInit({
        method: "DELETE",
        body,
        headers,
      })
    )
      .then(getErrorFromResponse)
      .then((response) => response.json());
  }
}

export default API;
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Account","link":"<a href=\"Account.html\">Account</a>"},{"title":"Alias","link":"<a href=\"Alias.html\">Alias</a>"},{"title":"AliasesEndpoint","link":"<a href=\"AliasesEndpoint.html\">AliasesEndpoint</a>"},{"title":"AliasesEndpoint#createAlias","link":"<a href=\"AliasesEndpoint.html#createAlias\">AliasesEndpoint &rtrif; createAlias</a>"},{"title":"AliasesEndpoint#deleteAlias","link":"<a href=\"AliasesEndpoint.html#deleteAlias\">AliasesEndpoint &rtrif; deleteAlias</a>"},{"title":"AliasesEndpoint#getAlias","link":"<a href=\"AliasesEndpoint.html#getAlias\">AliasesEndpoint &rtrif; getAlias</a>"},{"title":"AliasesEndpoint#getAliasesForAccount","link":"<a href=\"AliasesEndpoint.html#getAliasesForAccount\">AliasesEndpoint &rtrif; getAliasesForAccount</a>"},{"title":"AliasesEndpoint#updateAlias","link":"<a href=\"AliasesEndpoint.html#updateAlias\">AliasesEndpoint &rtrif; updateAlias</a>"},{"title":"API","link":"<a href=\"API.html\">API</a>"},{"title":"AuthEndpoint","link":"<a href=\"AuthEndpoint.html\">AuthEndpoint</a>"},{"title":"AuthEndpoint#isLoggedIn","link":"<a href=\"AuthEndpoint.html#isLoggedIn\">AuthEndpoint &rtrif; isLoggedIn</a>"},{"title":"AuthEndpoint#login","link":"<a href=\"AuthEndpoint.html#login\">AuthEndpoint &rtrif; login</a>"},{"title":"AuthEndpoint#logout","link":"<a href=\"AuthEndpoint.html#logout\">AuthEndpoint &rtrif; logout</a>"},{"title":"AuthEndpoint#signup","link":"<a href=\"AuthEndpoint.html#signup\">AuthEndpoint &rtrif; signup</a>"},{"title":"BaseModel","link":"<a href=\"BaseModel.html\">BaseModel</a>"},{"title":"Client","link":"<a href=\"Client.html\">Client</a>"},{"title":"Client#addFriend","link":"<a href=\"Client.html#addFriend\">Client &rtrif; addFriend</a>"},{"title":"Client#createAlias","link":"<a href=\"Client.html#createAlias\">Client &rtrif; createAlias</a>"},{"title":"Client#createPrivatePayload","link":"<a href=\"Client.html#createPrivatePayload\">Client &rtrif; createPrivatePayload</a>"},{"title":"Client#deleteAlias","link":"<a href=\"Client.html#deleteAlias\">Client &rtrif; deleteAlias</a>"},{"title":"Client#deleteMessage","link":"<a href=\"Client.html#deleteMessage\">Client &rtrif; deleteMessage</a>"},{"title":"Client#deletePrivatePayload","link":"<a href=\"Client.html#deletePrivatePayload\">Client &rtrif; deletePrivatePayload</a>"},{"title":"Client#getAlias","link":"<a href=\"Client.html#getAlias\">Client &rtrif; getAlias</a>"},{"title":"Client#getAliasesForAccount","link":"<a href=\"Client.html#getAliasesForAccount\">Client &rtrif; getAliasesForAccount</a>"},{"title":"Client#getFriendsForAlias","link":"<a href=\"Client.html#getFriendsForAlias\">Client &rtrif; getFriendsForAlias</a>"},{"title":"Client#getMessageById","link":"<a href=\"Client.html#getMessageById\">Client &rtrif; getMessageById</a>"},{"title":"Client#getMessagesForAlias","link":"<a href=\"Client.html#getMessagesForAlias\">Client &rtrif; getMessagesForAlias</a>"},{"title":"Client#getPrivatePayload","link":"<a href=\"Client.html#getPrivatePayload\">Client &rtrif; getPrivatePayload</a>"},{"title":"Client#groupMessagesByUniqueRecipients","link":"<a href=\"Client.html#groupMessagesByUniqueRecipients\">Client &rtrif; groupMessagesByUniqueRecipients</a>"},{"title":"Client#isLoggedIn","link":"<a href=\"Client.html#isLoggedIn\">Client &rtrif; isLoggedIn</a>"},{"title":"Client#login","link":"<a href=\"Client.html#login\">Client &rtrif; login</a>"},{"title":"Client#logout","link":"<a href=\"Client.html#logout\">Client &rtrif; logout</a>"},{"title":"Client#removeFriend","link":"<a href=\"Client.html#removeFriend\">Client &rtrif; removeFriend</a>"},{"title":"Client#sendMessage","link":"<a href=\"Client.html#sendMessage\">Client &rtrif; sendMessage</a>"},{"title":"Client#signup","link":"<a href=\"Client.html#signup\">Client &rtrif; signup</a>"},{"title":"Client#updateAlias","link":"<a href=\"Client.html#updateAlias\">Client &rtrif; updateAlias</a>"},{"title":"Client#updateMessage","link":"<a href=\"Client.html#updateMessage\">Client &rtrif; updateMessage</a>"},{"title":"Client#updatePrivatePayload","link":"<a href=\"Client.html#updatePrivatePayload\">Client &rtrif; updatePrivatePayload</a>"},{"title":"ClientStore","link":"<a href=\"ClientStore.html\">ClientStore</a>"},{"title":"FriendsEndpoint","link":"<a href=\"FriendsEndpoint.html\">FriendsEndpoint</a>"},{"title":"FriendsEndpoint#addFriend","link":"<a href=\"FriendsEndpoint.html#addFriend\">FriendsEndpoint &rtrif; addFriend</a>"},{"title":"FriendsEndpoint#getFriendsForAlias","link":"<a href=\"FriendsEndpoint.html#getFriendsForAlias\">FriendsEndpoint &rtrif; getFriendsForAlias</a>"},{"title":"FriendsEndpoint#removeFriend","link":"<a href=\"FriendsEndpoint.html#removeFriend\">FriendsEndpoint &rtrif; removeFriend</a>"},{"title":"Message","link":"<a href=\"Message.html\">Message</a>"},{"title":"MessagesEndpoint","link":"<a href=\"MessagesEndpoint.html\">MessagesEndpoint</a>"},{"title":"MessagesEndpoint#deleteMessage","link":"<a href=\"MessagesEndpoint.html#deleteMessage\">MessagesEndpoint &rtrif; deleteMessage</a>"},{"title":"MessagesEndpoint#getMessage","link":"<a href=\"MessagesEndpoint.html#getMessage\">MessagesEndpoint &rtrif; getMessage</a>"},{"title":"MessagesEndpoint#getMessagesForAlias","link":"<a href=\"MessagesEndpoint.html#getMessagesForAlias\">MessagesEndpoint &rtrif; getMessagesForAlias</a>"},{"title":"MessagesEndpoint#sendMessage","link":"<a href=\"MessagesEndpoint.html#sendMessage\">MessagesEndpoint &rtrif; sendMessage</a>"},{"title":"MessagesEndpoint#updateMessage","link":"<a href=\"MessagesEndpoint.html#updateMessage\">MessagesEndpoint &rtrif; updateMessage</a>"},{"title":"PrivatePayload","link":"<a href=\"PrivatePayload.html\">PrivatePayload</a>"},{"title":"PrivatePayloadsEndpoint","link":"<a href=\"PrivatePayloadsEndpoint.html\">PrivatePayloadsEndpoint</a>"},{"title":"PrivatePayloadsEndpoint#createPayload","link":"<a href=\"PrivatePayloadsEndpoint.html#createPayload\">PrivatePayloadsEndpoint &rtrif; createPayload</a>"},{"title":"PrivatePayloadsEndpoint#deletePayload","link":"<a href=\"PrivatePayloadsEndpoint.html#deletePayload\">PrivatePayloadsEndpoint &rtrif; deletePayload</a>"},{"title":"PrivatePayloadsEndpoint#getPayload","link":"<a href=\"PrivatePayloadsEndpoint.html#getPayload\">PrivatePayloadsEndpoint &rtrif; getPayload</a>"},{"title":"PrivatePayloadsEndpoint#updatePayload","link":"<a href=\"PrivatePayloadsEndpoint.html#updatePayload\">PrivatePayloadsEndpoint &rtrif; updatePayload</a>"},{"title":"WebSocketEndpoint","link":"<a href=\"WebSocketEndpoint.html\">WebSocketEndpoint</a>"},{"title":"WebSocketEndpoint#openWebSocketFor","link":"<a href=\"WebSocketEndpoint.html#openWebSocketFor\">WebSocketEndpoint &rtrif; openWebSocketFor</a>"},{"title":"onDeleteMessage","link":"<a href=\"global.html#event:onDeleteMessage\">onDeleteMessage</a>"},{"title":"onNewMessage","link":"<a href=\"global.html#event:onNewMessage\">onNewMessage</a>"},{"title":"onUpdateMessage","link":"<a href=\"global.html#event:onUpdateMessage\">onUpdateMessage</a>"},{"title":"createAccountFromAccountDTO","link":"<a href=\"global.html#createAccountFromAccountDTO\">createAccountFromAccountDTO</a>"},{"title":"createAliasFromAliasDTO","link":"<a href=\"global.html#createAliasFromAliasDTO\">createAliasFromAliasDTO</a>"},{"title":"createDefaultRequestInit","link":"<a href=\"global.html#createDefaultRequestInit\">createDefaultRequestInit</a>"},{"title":"CreateDefaultRequestInitOptions","link":"<a href=\"global.html#CreateDefaultRequestInitOptions\">CreateDefaultRequestInitOptions</a>"},{"title":"createJSONEncodedBody","link":"<a href=\"global.html#createJSONEncodedBody\">createJSONEncodedBody</a>"},{"title":"createMessageFromMessageDTO","link":"<a href=\"global.html#createMessageFromMessageDTO\">createMessageFromMessageDTO</a>"},{"title":"createPrivatePayloadFromPayloadDTO","link":"<a href=\"global.html#createPrivatePayloadFromPayloadDTO\">createPrivatePayloadFromPayloadDTO</a>"},{"title":"getErrorFromResponse","link":"<a href=\"global.html#getErrorFromResponse\">getErrorFromResponse</a>"},{"title":"messageEventDetails","link":"<a href=\"global.html#messageEventDetails\">messageEventDetails</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>
